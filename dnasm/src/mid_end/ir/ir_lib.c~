//===========================================================================
// ir_lib.c
//   Copyright (C) 2012 Free Software Foundation, Inc.
//   Originally by ZhaoFeng Liang <zhf.liang@hotmail.com>
//
//This file is part of DTAHS_DCC.
//
//DTAHS_DCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 2 of the License, or 
//(at your option) any later version.
//
//DTAHS_DCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with DTHAS; If not, see <http://www.gnu.org/licenses/>.  
//===========================================================================

#include	"dcc_global.h"
#include	"dcc_type.h"
#include	"dcc_symtbl.h"
#include	<stdio.h>
#include	"dcc_main.h"
#include	"dcc_lex_char.h"
#include	"dcc_lex_word.h"
#include	"dcc_parse.h"
#include	"dcc_seman.h"
#include	"dcc_frame.h"
#include	"dcc_ir.h"
#include	"dcc_prototype.h"

#define	IR_DEBUG

PRIVATE	s8 word_info[IR_WORD_NUM][IR_WORD_LEN] = {
					"AUTO","BREAK","CASE","CHAR","CONST","CONTINUE","DEFAULT","DO","DOUBLE","ELSE",
					"ENUM","EXTERN","FLOAT","FOR","GOTO","IF","INT","LONG",	"REGISTER","RETURN",
					"SHORT","SIGNED","SIZEOF","STATIC","STRUCT","SWITCH","TYPEDEF","UNION",	"UNSIGNED","VOID",
					"VOLATILE","WHILE","IDENTIFIER","SPACE","COMMENT_S","COMMENT_M_BEGIN","COMMENT_M_END","SEMICOLON","CONST_DEC","TYPE_NAME",
					"ELLIPSIS","","CONST_S_INT_8","CONST_S_INT_16","CONST_S_INT_32","CONST_S_INT_64","CONST_S_INT_128","CONST_U_INT_8","CONST_U_INT_16","CONST_U_INT_32",
					"CONST_U_INT_64","CONST_U_INT_128","","","","CONST_NL","CONST_HT","CONST_VT","CONST_BS","CONST_CR",
					"CONST_FF","CONST_BEL","CONST_BACKSLASH","CONST_QMARK","CONST_S_QUOTE","CONST_D_QUOTE","CONST_OCT","CONST_HEX","","CONST_STRING",
					"CONST_FLOAT","CONST_DOUBLE","CONST_S_SCIENCE","CONST_U_SCIENCE","","","","","","",
					"+","-","*","/","%","&","!","~","|","^",
					"++","--","&&","||","==","<=",">=","!=","+=","-=",
					"*=","/=","%=","<<",">>","<<=",">>=","&=","|=","^=",
					"=","?","<",">",",",".","->",":","paramlist","",
					"(",")","[","]","{","}","struct","array"
				};

PRIVATE	s8 sts_kind_info[2][IR_WORD_LEN] = {"IR_JUMP","IR_EXP"};

PRIVATE	s8 exp_kind_info[8][IR_WORD_LEN] = {"IR_ABOP", "IR_CALL", "IR_VARADDR", "IR_ASSIGN", "IR_COND", "IR_RELATE", "IR_POSTFIX", "UNARY"};


//===========================================================================
// ir_explist_print(struct ir_explist *explist)
//===========================================================================
PUBLIC	void	print_ir()
{
//--------------------------
//test
#ifdef	IR_DEBUG
	printf("-- print_ir -- (cur_file=0x%x)\n",cur_file);
#endif
//--------------------------

	ir_file_print(cur_file);
}

//===========================================================================
// ir_explist_print(struct ir_explist *explist)
//===========================================================================
PUBLIC	void	ir_file_print(struct ir_file *f)
{
//--------------------------
//test
#ifdef	IR_DEBUG
	printf("-- ir_file_print -- \n");
#endif
//--------------------------

	for(; f; f=f->tail)
	{
		ir_stslist_print(f->stslist);
	}
}

//===========================================================================
// ir_explist_print(struct ir_explist *explist)
//===========================================================================
PUBLIC	void	ir_stslist_print(struct ir_stslist *stslist)
{
//--------------------------
//test
#ifdef	IR_DEBUG
	printf("-- ir_stslist_print -- \n");
#endif
//--------------------------

	for(; stslist; stslist=stslist->tail)
	{
		ir_sts_print(stslist->sts);
	}
}

//===========================================================================
// ir_explist_print(struct ir_explist *explist)
//===========================================================================
PUBLIC	void	ir_sts_print(struct ir_sts *sts)
{
//--------------------------
//test
#ifdef	IR_DEBUG
	printf("%5s %10s (sts=0x%10x) \n","","-- ir_sts_print --",sts);
#endif
//--------------------------

	if(sts)
	{
//--------------------------
//test
#ifdef	IR_DEBUG
	printf("%5s %10s (sts_kind=%10s) \n","","----",sts_kind_info[sts->k]);
#endif
//--------------------------

		switch(sts->k)
		{
			case IR_JUMP:
				break;
			case IR_EXP:
				ir_explist_print(sts->s.exp_sts.explist);
				break;
		}
	}
}

//===========================================================================
// ir_explist_print(struct ir_explist *explist)
//===========================================================================
PUBLIC	void	ir_explist_print(struct ir_explist *explist)
{
//--------------------------
//test
#ifdef	IR_DEBUG
	printf("%15s %10s (explist=0x%x) \n","","-- ir_explist_print --",explist);
#endif
//--------------------------


	for(; explist; explist=explist->tail)
	{
		ir_exp_print(explist->exp);
	}
}


//===========================================================================
// ir_explist_print(struct ir_explist *explist)
//===========================================================================
PUBLIC	void	ir_exp_print(struct ir_exp *exp)
{
//--------------------------
//test
#ifdef	IR_DEBUG
	printf("%20s %10s (s:exp=0x%x) \n","","-- ir_exp_print --",exp);
#endif
//--------------------------

	struct ir_exp *t;

	if(exp)
	{

//--------------------------
//test
#ifdef	IR_DEBUG
	printf("%25s ----(exp_kind=%s) \n","",exp_kind_info[exp->k - IR_EXPKIND_BASE]);
#endif
//--------------------------

		switch(exp->k)
		{
			case IR_ABOP:
				for(; exp->e.abop.left; exp=exp->e.abop.right)
				{
					//ir_var_print(exp->e.abop.left);
					ir_exp_print(exp->e.abop.left);

					printf("%s\n", &word_info[exp->e.abop.op][0]);

					ir_exp_print(exp->e.abop.right);
				}
				printf("\n");

				break;

			case IR_UNARY:
				printf("%s\n", &word_info[exp->e.unary.op][0]);

				ir_exp_print(exp->e.unary.left);				

				printf("\n");

				break;

			case IR_CALL:
				printf("(func) %s\n", exp->e.call.label_name);
				//ir_pvlist_print(&(exp->e.call.pvlist));
				ir_exp_print(exp->e.call.ppv);

				break;

			case IR_VARADDR:
				ir_var_print(exp);
				break;

			case IR_ASSIGN:
				//for test
				//printf("-- IR_ASSIGN(s), exp=0x%x, exp->e.assign.res=0x%x, exp->e.assign.val=0x%x\n",exp, exp->e.assign.res,exp->e.assign.val);

				//exp=exp->e.assign.res;
			
				
				//modi on 2013-6-22
				for(; exp; exp=exp->e.assign.val)
				{
					//ir_var_print(exp->e.assign.res);
					ir_exp_print(exp->e.assign.res);

					printf(" %s ", &word_info[exp->e.assign.op][0]);


					//for test
					//printf("\n, OP=%d, right=%x\n", exp->e.assign.op,exp->e.assign.val);
				}
				//printf("-- IR_ASSIGN(e)\n\n");
				

				break;

			case IR_COND:
				printf("condition:");
				ir_var_print(exp->e.cond.cond);
	
				printf(" ? ");
			
				for(; exp->e.cond.op_1; exp=exp->e.cond.op_2)
				{
					ir_var_print(exp->e.cond.op_1);
					printf(" : ");
				}
				printf("\n");

				break;

			case IR_RELATE:
			
				t = exp->e.relate.left;

				ir_var_print(t->e.relate.left);
				printf("%s ", &word_info[t->e.relate.op][0]);

				t = exp->e.relate.right;

				ir_var_print(t->e.relate.left);
				printf("%s ", &word_info[t->e.relate.op][0]);
			

				printf("\n");

				break;

			case IR_POSTFIX:
			
				switch(exp->e.postfix.op)
				{
					case IR_STRUCT:
						ir_var_print(exp->e.postfix.left);		//struct name
						//printf(".");
						//ir_var_print(exp->e.postfix.right);		//member name
						//for test
						//printf("ir_lib::struct=%s\n",exp->e.postfix.left->e.var.name);
						break;

					case IR_POINTER:
						ir_var_print(exp->e.postfix.left);
						printf("->");
						break;

					case IR_ARRAY:
						ir_var_print(exp->e.postfix.left);
						printf("[");
						ir_exp_print(exp->e.postfix.right);
						printf("]\n");
						break;

					/*
					case IR_CALL:
					//case IR_PARAMLIST:
						//ir_var_print(exp->e.postfix.left);
						printf("%s(",exp->e.call.label_name);

						//printf("(");

						for(exp; exp->e.assign.res; exp->e.assign.val)
						{
							ir_exp_print(exp->e.assign.res);
							printf(",");
						}

						printf(")");
						break;
					*/
					case IR_INC:
						ir_var_print(exp->e.postfix.left);
						printf("++");
						break;

					case IR_DEC:
						ir_var_print(exp->e.postfix.left);
						printf("--");
						break;

					default:
						break;
				}

				printf("\n");

				break;

			default:
				break;
		}
	}

//--------------------------
//test
#ifdef	IR_DEBUG
//	printf("\n%25s ----ir_exp_print(e) \n","");
#endif
//--------------------------
}


//===========================================================================
// ir_var_print(struct ir_exp* exp)
//===========================================================================
PUBLIC	void	ir_var_print(struct ir_exp* exp)
{
//--------------------------
//test
#ifdef	IR_DEBUG
	printf("%30s ----ir_var_print(s) ,kind=%d, var_type=%d\n","", exp->k,exp->e.var.var_type);
	//printf("%30s ----ir_var_print(s) ,kind=%d\n","", exp->k);
#endif
//--------------------------

	s32 var_type	= exp->e.var.var_type;
	u32 var_len	= exp->e.var.var_len;

	if(var_type > 100)
	{
		var_type	= STRUCT;
	}

	switch(var_type)
	{
		case INT:
			printf("%35s (name=%s)%d ","", (s8*)(exp->e.var.name), *(s32*)(exp->e.var.var_addr));
			break;
		case CHAR:
			printf("%35s (char)%s ","", (s8*)(exp->e.var.name), (s8*)(exp->e.var.var_addr));			
			break;
		case STRUCT:
			printf("%35s (struct)%s ", "", (s8*)(exp->e.var.name));			
			break;
		default:
			break;
	}



}


//===========================================================================
// ir_pvlist_print(struct ir_pvlist *pvlist)
//===========================================================================
PUBLIC	void	ir_pvlist_print(struct ir_pvlist *pvlist)
{
	printf("	parmlist:(");

	for(; pvlist; pvlist=pvlist->tail)
	{
		ir_var_print(pvlist->exp);
		printf(",");
	}

	printf(")\n");
}

